return void
precess commands(execution pointer)
{
	{pipe command}(execution, pipe's tree's first command, stdin)
	pipe tree is pipe tree's next
	while pipe tree's next is not null
	{
		{pipe command}(execution, pipe's tree's first command, execution's prev)
		pipe tree is pipe tree's next
	}
	if pipe tree's second is null
		{last command}(execution, pipe's tree's first command)
	else
	{
		{pipe command}(execution, pipe's tree's first command, execution's prev)
		{last command}(execution, pipe's tree's second command)
	}
}

return integer
process one command(constant simple command, exit number)
{
	table
	exit number

	if !{set table}(table pointer,  simple command, stdin, stdout)
		return fail
	table's argument is {merge}(simple command)
	if command {is builtin}(command)
		exit number = {builtin}(table, env list, exit number)
	else
		exit number = {execute one command at child}(table)
	return exit number
}

return integer
execute one command at child(constant table)
{
	child pid
	env array
	status

	child pid is result of fork
	if child pid is negative
		exit program
	else if child pid is zero
	{
		{apply redirect}(table.input, table.output)
		{execute at child}(table, env list)
	}
	wait(child, status pointer)
	return WEXITSTATUS(status)
}

return bool
is executable(constant command, constant env array)
{
	index
	env's path
	path

	index is zero
	while env's index is not null
	{
		if env's index is start "PATH"
			env's path is env's index except "PATH="
		index increase one
	}
	path is result of split env's path by ':'
	if path is null
		exit fail
	index is zero
	while path's index is not null
	{
		path execute is result of {merge}(path's index, command)
		if {is possible(path execute)}
			return true
		index increase one
	}
	return false
}

return bool
is possible(constant path)
{
	struct stat
	mode

	if stat(path, stat pointer) is negative
		exit fail
	mode is stat's st_mode & 0777(8ì§„ìˆ˜)
	return ( ((mode >> 6) & 1) & ((mode >> 3) & 1) & (mode & 1) )
}

return void
apply redirect(integer input, integer output)
{
	if input is not stdin
	{
		dup stdin to input
		close stdin
	}
	if output is not stdout
	{
		dup stdout to output
		close stdout
	}
}
