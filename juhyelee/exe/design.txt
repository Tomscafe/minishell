명령어는 파싱부에서 트리 구조로 들어옴
PIPE1 first(com)cmd (word)option and args (rd)< or > or << or >>
	  second(com)cmd (word)option and args (rd)< or > or << or >>
PIPE2 first(com)cmd (word)option and args (rd)< or > or << or >>
	  second(com)cmd (word)option and args (rd)< or > or << or >>
PIPE3 first(com)cmd (word)option and args (rd)< or > or << or >>
	  second(com)cmd (word)option and args (rd)< or > or << or >>
...

PIPEn first(com)cmd (word)option and args (rd)< or > or << or >>
	  second(com)cmd (word)option and args (rd)< or > or << or >>
	  or
	  second(com)(null) (word)(null) (rd)(null) 

structures
{
	redirection(linked list) : symbol(string), file(string)
	simple : command(string), word(stirng) // word는 명령어 인자값(option 포함)
	command : simple command(simple), redirection(redirection)
	pipe(linked list + tree) : first command(command), second command(command)
}

table
{
	string command
	stirng argument
	string array env
	int input
	int output
}

execution structure : execution
{
	pipe tree pointer currp
	int pipefd[2]
	int prevfd
}

void execute(pipe tree pointer pipe)
{
	execution exe
	process first command(&exe)
	process middle command(&exe)
	process last command(&exe)
}

void process first command(execution pointer exe)
{
	table table

	table.command = exe->currp->first->com
	table.argument = exe->currp->first->word
	table.input = stdin
	if exe->currp->second is null and is builtin(exe->curr->first->com)
	{
		table.output = stdout
		if not fail to set redirection(&table, exe->currp->first->rd)
			builtin(table)
	}
	else
	{
		if fail to pipe(exe->pipefd)
		{
			print error
			return
		}
		table.output = exe->pipefd[write]
		if not fail to set redirection(&table, exe->currp->first->rd)
				execute at child(table)
	}
}

void process middle command(execution pointer exe)
{
	table table
	
	while exe->currp->next is not null
	{
		table.command = exe->currp->second->com
		table.argument = exe->currp->second->word
		table.input = exe->prevfd
		if fail to pipe(exe->pipefd)
			table.output = exe->pipefd[write]
		if not fail to set redirection(&table, exe->currp->second->rd)
			execute at child(table)
		exe->currp = exe->currp->next
	}
}

void process last command(execution pointer exe)
{
	table table
	
	if exe->currp->second is not null
	{
		table.command = exe->currp->second->com
		table.argument = exe->currp->second->word
		table.input = exe->prevfd
		table.output = stdout
		if not fail to set redirection(&table, exe->currp->second->rd)
				execute at child(table)
	}
	close(exe->prevfd)
}

int is builtin(string command)
{
	if command equal echo
		return true
	if command equal exit
		return true
	if command equal cd
		return true
	if command equal pwd
		return true
	if command equal export
		return true
	if command equal unset
		return true
	if command equal env
		return true
	return false
}

int	set redirection(table pointer table, list pointer rd)
{
	while rd is not null
	{
		if rd->symbol is >
			table->output = open(rd->file, write only)
		else if rd->symbol is >>
			table->output = open(rd->file, write only | append)
		else if rd->symbol is <
			table->input = open(rd->file, read only)
		else
		{
			heredoc(rd->file)
			table->input = open(heredocfile, read only)
		}
		if table->input is -1
		{
			printf("minishell: %s: No such file or directory\n", rd->file);
			return false
		}
		rd = next of rd
	}
	return true
}

void builtin(table table)
{
	if table.command equal echo
		echo(table)
	else if table.command equal exit
		exit(table)
	else if table.command equal cd
		cd(table)
	else if table.command equal pwd
		pwd(table)
	else if table.command equal export
		export(table)
	else if table.command equal unset
		unset(table)
	else if table.command equal env
		env(table)
}

void execute at child (table table, execution pointer exe)
{
	string path

	create child
	if fail to create child
	{
		print error
		return
	}
	else if is child
	{
		dup2(table.input, stdin)
		dup2(table.output, stdout)
		close(table.input)
		close(table.output)
		close exe->pipefd
		path = is executable(table.command)
		execve(path, table.argument, table.env)
	}
	wait child
	exe->prevfd = dup(exe->pipefd[read])
	close exe->pipefd
}
