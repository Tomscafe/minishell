명령어는 파싱부에서 트리 구조로 들어옴
PIPE1 first(com)cmd (word)option and args (rd)< or > or << or >>
	  second(com)cmd (word)option and args (rd)< or > or << or >>
PIPE2 first(com)cmd (word)option and args (rd)< or > or << or >>
	  second(com)cmd (word)option and args (rd)< or > or << or >>
PIPE3 first(com)cmd (word)option and args (rd)< or > or << or >>
	  second(com)cmd (word)option and args (rd)< or > or << or >>
...

PIPEn first(com)cmd (word)option and args (rd)< or > or << or >>
	  second(com)cmd (word)option and args (rd)< or > or << or >>
	  or
	  second(com)(null) (word)(null) (rd)(null) 

structures
{
	redirection(linked list) : symbol(string), file(string)
	simple : command(string), word(stirng) // word는 명령어 인자값(option 포함)
	command : simple command(simple), redirection(redirection)
	pipe(linked list + tree) : first command(command), second command(command)
}

table
{
	string command
	stirng argument
	int input
	int output
}

execution structure : execution
{
	pipe tree pointer currp
	int pipefd[2]
	int prevfd
	int is first
}

void execute(pipe tree pointer pipe)
{
	executtion exe
	table command table

	exe.currp = pipe
	exe.is first = true
	if exe.currp->second is null and is builtin
	{
		if not fail to create first command table(&table, &exe, stdin, stdout)
			builtin(command table)
	}
	else
	{
		create first command table(&command table, exe.currp->first, stdin, -1)
		execute at child(&exe)
		close(exe.pipefd)
	}
	exe.is first = false
	while exe.currp->next is not null
	{
		create second command table(&command table, exe.currp->second, exe.prevfd, -1)
		execute at child(&exe)
		close(exe.pipefd)
		exe.currp = exe.currp->next
	}
	if exe.currp->second is not null
	{
		create second command table(&command table, exe.currp->second, exe.prevfd , stdout)
		execute at child(&exe)
		close(exe.prevfd)
	}
}

int create command table(table pointer table, executtion pointer exe, int indef, int outdef)
{
	table->input = indef
	table->output = outdef
	if exe->is first is true
	{
		table->command = exe->currp->first->com
		table->argument = exe->currp->first->word
		if fail to set redirection(table, exe->currp->first->rd)
			return false
	}
	else
	{
		table->command = exe->currp->second->com
		table->argument = exe->currp->second->word
		if fail to set redirection(table, exe->currp->second->rd)
			return false
	}
	return true
}

int	set redirection(table pointer table, list pointer rd)
{
	while rd is not null
	{
		if rd->symbol is >
			table->output = open(rd->file, write only)
		else if rd->symbol is >>
			table->output = open(rd->file, write only | append)
		else if rd->symbol is <
			table->input = open(rd->file, read only)
		else
		{
			heredoc(rd->file)
			table->input = open(heredocfile, read only)
		}
		if table->input is -1
		{
			printf("minishell: %s: No such file or directory\n", rd->file);
			return false
		}
		rd = next of rd
	}
	return true
}